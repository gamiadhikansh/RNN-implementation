# -*- coding: utf-8 -*-
"""RNN on monthly_milk

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w3l2KO09XyE34rnneItGzm8p6MDyzHHe
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

df = pd.read_csv('/content/monthly-milk-production.csv')

df.head()

df.dtypes

df = pd.read_csv('/content/monthly-milk-production.csv',index_col='Month',parse_dates=True)

df.head()

df.shape

df.isnull().sum()

df.describe()

df.plot(figsize=(12, 6))

from statsmodels.tsa.seasonal import seasonal_decompose
results = seasonal_decompose(df['Milk Production'])
results.plot()

train = df.iloc[:156]
test = df.iloc[156:]

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
scaler.fit(train)
scaled_train = scaler.transform(train)
scaled_test = scaler.transform(test)

from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator

# Define the number of input time steps
n_input = 3
# Define the number of features
n_features = 1

# Create a TimeseriesGenerator for generating sequences with n_input time steps
generator = TimeseriesGenerator(scaled_train,  # Input data
                                scaled_train,  # Targets (labels)
                                length=n_input,  # Length of the output sequences
                                batch_size=1)  # Number of samples in each batch

# Generate the first sequence of input-output pairs
X, y = generator[0]
print(f'Given the Array: \n{X.flatten()}')  # Print the input sequence
print(f'Predict this y: \n {y}')  # Print the corresponding output

# Update n_input to 12 months
n_input = 12

# Create a new TimeseriesGenerator for generating sequences with 12 time steps
generator = TimeseriesGenerator(scaled_train,  # Input data
                                scaled_train,  # Targets (labels)
                                length=n_input,  # Length of the output sequences
                                batch_size=1)  # Number of samples in each batch

# define model
# Define the model architecture
model = Sequential()
model.add(LSTM(100, activation='relu', input_shape=(n_input, n_features)))
model.add(Dense(1))

# Compile the model
model.compile(optimizer='adam', loss='mse')

# Display model summary
model.summary()

# Train the model
model.fit(generator, epochs=5)

loss_per_epoch = model.history.history['loss']
plt.plot(range(len(loss_per_epoch)),loss_per_epoch)

last_train_batch = scaled_train[-12:]

last_train_batch = last_train_batch.reshape((1, n_input, n_features))

model.predict(last_train_batch)

scaled_test[0]

test_predictions = []

first_eval_batch = scaled_train[-n_input:]
current_batch = first_eval_batch.reshape((1, n_input, n_features))

for i in range(len(test)):

    # get the prediction value for the first batch
    current_pred = model.predict(current_batch)[0]

    # append the prediction into the array
    test_predictions.append(current_pred)

    # use the prediction to update the batch and remove the first value
    current_batch = np.append(current_batch[:,1:,:],[[current_pred]],axis=1)

test_predictions

test.head()

true_predictions = scaler.inverse_transform(test_predictions)

test['Predictions'] = true_predictions

test.plot(figsize=(14,5))

from sklearn.metrics import mean_squared_error
from math import sqrt
# The column name is likely 'Milk Production' instead of 'Production'.
rmse=sqrt(mean_squared_error(test['Milk Production'],test['Predictions']))
print(rmse)